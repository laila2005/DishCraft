const express = require("express");
const dotenv = require("dotenv");
const mongoose = require("mongoose");
const cors = require("cors");
const Ingredient = require("./models/Ingredient");
const RecipeComponent = require("./models/RecipeComponent");

dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

// CORS Configuration
app.use(cors());

// Middleware to parse JSON bodies
app.use(express.json());

// Connect to MongoDB
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("MongoDB Connected...");
  } catch (err) {
    console.error("Error connecting to MongoDB:", err.message);
    process.exit(1);
  }
};

connectDB();

// Basic error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send("Something broke!");
});

// --- API Endpoints ---

// Root endpoint
app.get("/", (req, res) => {
  res.send("Welcome to DishCraft API!");
});

// GET all ingredients
app.get("/api/ingredients", async (req, res) => {
  try {
    const ingredients = await Ingredient.find().sort({ name: 1 });
    res.json(ingredients);
  } catch (err) {
    console.error(err.message);
    res.status(500).send("Server Error fetching ingredients");
  }
});

// POST to generate a recipe
app.post("/api/generate-recipe", async (req, res) => {
  const { preferences } = req.body; // preferences will contain user choices like dietary, cuisine, ingredients

  try {
    // --- Simple Rule-Based Recipe Generation Logic (MVP) ---
    // This is a basic example. You can expand this significantly.

    let selectedProtein = null;
    let selectedVegetable = null;
    let selectedCarb = null;
    let selectedSauce = null;
    let selectedMethod = null;
    let selectedTemplate = null;

    // 1. Select a protein (e.g., based on preference or random)
    const proteins = await RecipeComponent.find({ type: "protein" });
    if (proteins.length > 0) {
      selectedProtein = proteins[Math.floor(Math.random() * proteins.length)];
    }

    // 2. Select a vegetable
    const vegetables = await RecipeComponent.find({ type: "vegetable" });
    if (vegetables.length > 0) {
      selectedVegetable = vegetables[Math.floor(Math.random() * vegetables.length)];
    }

    // 3. Select a carb
    const carbs = await RecipeComponent.find({ type: "carb" });
    if (carbs.length > 0) {
      selectedCarb = carbs[Math.floor(Math.random() * carbs.length)];
    }

    // 4. Select a sauce base
    const sauces = await RecipeComponent.find({ type: "sauce_base" });
    if (sauces.length > 0) {
      selectedSauce = sauces[Math.floor(Math.random() * sauces.length)];
    }

    // 5. Select a cooking method compatible with selected protein/veg
    const cookingMethods = await RecipeComponent.find({ type: "cooking_method" });
    if (cookingMethods.length > 0) {
      // For MVP, just pick one. Later, filter by compatible_types.
      selectedMethod = cookingMethods[Math.floor(Math.random() * cookingMethods.length)];
    }

    // 6. Select an instruction template based on cooking method
    const instructionTemplates = await RecipeComponent.find({ type: "instruction_template" });
    if (instructionTemplates.length > 0) {
      // For MVP, just pick one. Later, filter by method tags.
      selectedTemplate = instructionTemplates[Math.floor(Math.random() * instructionTemplates.length)];
    }

    // Construct the recipe object
    const generatedRecipe = {
      title: `Quick ${selectedMethod ? selectedMethod.name : ""} ${selectedProtein ? selectedProtein.name : "Dish"} with ${selectedVegetable ? selectedVegetable.name : "Veggies"}`,
      description: "A simple, delicious, and customizable recipe generated by DishCraft.",
      components: {
        protein: selectedProtein ? selectedProtein.name : "N/A",
        vegetable: selectedVegetable ? selectedVegetable.name : "N/A",
        carb: selectedCarb ? selectedCarb.name : "N/A",
        sauce: selectedSauce ? selectedSauce.name : "N/A",
        cookingMethod: selectedMethod ? selectedMethod.name : "N/A",
      },
      instructions: selectedTemplate ? selectedTemplate.steps.map(step => {
        // Simple placeholder replacement for MVP
        let newStep = step.replace("[protein]", selectedProtein ? selectedProtein.name.toLowerCase() : "protein");
        newStep = newStep.replace("[vegetables]", selectedVegetable ? selectedVegetable.name.toLowerCase() : "vegetables");
        newStep = newStep.replace("[fat source, e.g., 1-2 tbsp olive oil]", "1-2 tbsp olive oil");
        newStep = newStep.replace("[seasonings, e.g., salt, pepper, paprika, dried herbs]", "salt, pepper, and your favorite herbs");
        newStep = newStep.replace("[sauce_base or seasonings, e.g., soy sauce, herbs, spices]", selectedSauce ? selectedSauce.name.toLowerCase() : "sauce");
        newStep = newStep.replace("[carb, e.g., rice or quinoa]", selectedCarb ? selectedCarb.name.toLowerCase() : "carb");
        newStep = newStep.replace("[side, e.g., bread]", "a side dish");
        newStep = newStep.replace("[temperature, e.g., 200째C or 400째F]", "200째C (400째F)");
        newStep = newStep.replace("[X]", "15-20"); // Placeholder for time
        newStep = newStep.replace("[Y]", "5-7"); // Placeholder for time
        newStep = newStep.replace("[Z]", "3-5"); // Placeholder for time
        newStep = newStep.replace("[harder vegetables, e.g., onions, carrots, bell peppers]", "harder vegetables");
        newStep = newStep.replace("[softer vegetables, e.g., spinach, mushrooms, zucchini]", "softer vegetables");
        newStep = newStep.replace("[aromatics, e.g., minced garlic]", "aromatics like minced garlic");
        return newStep;
      }) : ["No instructions available."],
      // Add more details like cooking time, difficulty, etc., from selected components
      cookingTime: selectedMethod && selectedMethod.cooking_time_range ? `${selectedMethod.cooking_time_range.min}-${selectedMethod.cooking_time_range.max} minutes` : "N/A",
      difficulty: selectedMethod && selectedMethod.difficulty ? selectedMethod.difficulty : "N/A",
    };

    res.json(generatedRecipe);
  } catch (err) {
    console.error("Error generating recipe:", err.message);
    console.error(err.stack);
    res.status(500).send("Server Error generating recipe");
  }
});

// Start the server
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
