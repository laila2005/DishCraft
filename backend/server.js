const express = require("express");
const dotenv = require("dotenv");
const mongoose = require("mongoose");
const cors = require("cors");
const Ingredient = require("./models/Ingredient");
const RecipeComponent = require("./models/RecipeComponent");
const Meal = require("./models/Meal"); // Import Meal model
const MealPlan = require("./models/MealPlan"); // Import MealPlan model

dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

// CORS Configuration
app.use(cors());

// Middleware to parse JSON bodies
app.use(express.json());

// Connect to MongoDB
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("MongoDB Connected...");
  } catch (err) {
    console.error("Error connecting to MongoDB:", err.message);
    process.exit(1);
  }
};

connectDB();

// Basic error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send("Something broke!");
});

// --- API Endpoints ---

// Root endpoint
app.get("/", (req, res) => {
  res.send("Welcome to DishCraft API!");
});

// GET all ingredients
app.get("/api/ingredients", async (req, res) => {
  try {
    const ingredients = await Ingredient.find().sort({ name: 1 });
    res.json(ingredients);
  } catch (err) {
    console.error(err.message);
    res.status(500).send("Server Error fetching ingredients");
  }
});

// POST generate recipe
app.post("/api/generate-recipe", async (req, res) => {
  try {
    const { preferences } = req.body; // preferences will be used later

    // --- Recipe Generation Logic (Rule-Based) ---
    // This is a simplified version. You will expand this significantly.

    // 1. Select a protein (e.g., based on preference or random)
    const proteinOptions = await RecipeComponent.find({ type: "protein" });
    const selectedProtein = proteinOptions[Math.floor(Math.random() * proteinOptions.length)];

    // 2. Select a vegetable
    const vegetableOptions = await RecipeComponent.find({ type: "vegetable" });
    const selectedVegetable = vegetableOptions[Math.floor(Math.random() * vegetableOptions.length)];

    // 3. Select a carb
    const carbOptions = await RecipeComponent.find({ type: "carb" });
    const selectedCarb = carbOptions[Math.floor(Math.random() * carbOptions.length)];

    // 4. Select a sauce/flavor profile
    const sauceOptions = await RecipeComponent.find({ type: "sauce_base" });
    const selectedSauce = sauceOptions[Math.floor(Math.random() * sauceOptions.length)];

    // 5. Select a cooking method
    const methodOptions = await RecipeComponent.find({ type: "cooking_method" });
    const selectedMethod = methodOptions[Math.floor(Math.random() * methodOptions.length)];

    // Construct a simple title and description
    const title = `${selectedMethod.name} ${selectedProtein.name} with ${selectedVegetable.name}`;
    const description = `A simple, delicious, and customizable recipe generated by DishCraft.`;

    // Basic instructions (will be improved later)
    const instructions = selectedMethod.steps ? selectedMethod.steps.map(step => {
        let newStep = step;
        newStep = newStep.replace("{protein}", selectedProtein.name.toLowerCase());
        newStep = newStep.replace("{vegetable}", selectedVegetable.name.toLowerCase());
        newStep = newStep.replace("{carb}", selectedCarb.name.toLowerCase());
        newStep = newStep.replace("{sauce}", selectedSauce.name.toLowerCase());
        return newStep;
      }) : ["No instructions available."];

    const generatedRecipe = {
      title,
      description,
      components: {
        protein: selectedProtein.name,
        vegetable: selectedVegetable.name,
        carb: selectedCarb.name,
        sauce: selectedSauce.name,
        cookingMethod: selectedMethod.name,
      },
      instructions,
      cookingTime: selectedMethod && selectedMethod.cooking_time_range ? `${selectedMethod.cooking_time_range.min}-${selectedMethod.cooking_time_range.max} minutes` : "N/A",
      difficulty: selectedMethod && selectedMethod.difficulty ? selectedMethod.difficulty : "N/A",
    };

    res.json(generatedRecipe);
  } catch (err) {
    console.error("Error generating recipe:", err.message);
    console.error(err.stack);
    res.status(500).send("Server Error generating recipe");
  }
});

// --- Meal Plan API Endpoints ---

// POST create a new meal plan
app.post("/api/meal-plans", async (req, res) => {
  try {
    const { name } = req.body;
    if (!name) {
      return res.status(400).json({ message: "Meal plan name is required." });
    }
    const newMealPlan = new MealPlan({ name });
    await newMealPlan.save();
    res.status(201).json(newMealPlan);
  } catch (err) {
    console.error("Error creating meal plan:", err.message);
    res.status(500).send("Server Error creating meal plan");
  }
});

// GET all meal plans
app.get("/api/meal-plans", async (req, res) => {
  try {
    const mealPlans = await MealPlan.find().populate("meals"); // Populate meals for full details
    res.json(mealPlans);
  } catch (err) {
    console.error("Error fetching meal plans:", err.message);
    res.status(500).send("Server Error fetching meal plans");
  }
});

// POST add a generated recipe to a meal plan
app.post("/api/meal-plans/:planId/add-recipe", async (req, res) => {
  try {
    const { planId } = req.params;
    const { recipeDetails, mealType } = req.body;

    if (!recipeDetails || !recipeDetails.title) {
      return res.status(400).json({ message: "Recipe details are required." });
    }

    const mealPlan = await MealPlan.findById(planId);
    if (!mealPlan) {
      return res.status(404).json({ message: "Meal plan not found." });
    }

    const newMeal = new Meal({
      recipeTitle: recipeDetails.title,
      recipeDetails: recipeDetails, // Store the full recipe object
      mealType: mealType || "dinner", // Default to dinner if not provided
    });
    await newMeal.save();

    mealPlan.meals.push(newMeal._id);
    await mealPlan.save();

    res.status(200).json({ message: "Recipe added to meal plan successfully!", mealPlan });
  } catch (err) {
    console.error("Error adding recipe to meal plan:", err.message);
    res.status(500).send("Server Error adding recipe to meal plan");
  }
});

// Start the server
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
